name: Release

on:
  push:
    tags:
      - "v*"
      - "*.*.*"

permissions:
  contents: write

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  # Safety toggle: macOS signing/notarization is disabled by default to avoid breaking builds.
  # To enable, set a GitHub Actions repository variable: MACOS_SIGNING_ENABLED=true
  MACOS_SIGNING_ENABLED: ${{ vars.MACOS_SIGNING_ENABLED }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Generate release notes
        run: node scripts/extract-release-notes.js "${{ github.ref_name }}" > release_notes.md

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');
            const tag = context.ref.replace('refs/tags/', '');
            const isPrerelease = /-(alpha|beta|rc)(?:[.-]\d+)?$/i.test(tag);
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: `Tandem ${tag}`,
              body: releaseNotes,
              draft: true,
              prerelease: isPrerelease,
              make_latest: isPrerelease ? 'false' : 'true',
              generate_release_notes: false
            });
            return data.id;

  build-release:
    name: Build (${{ matrix.platform }})
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            engine_asset: tandem-engine-linux-x64.tar.gz
            tui_asset: tandem-tui-linux-x64.tar.gz
            standalone_archive: tar.gz
          - platform: macos-latest
            target: x86_64-apple-darwin
            engine_asset: tandem-engine-darwin-x64.zip
            tui_asset: tandem-tui-darwin-x64.zip
            standalone_archive: zip
          - platform: macos-latest
            target: aarch64-apple-darwin
            engine_asset: tandem-engine-darwin-arm64.zip
            tui_asset: tandem-tui-darwin-arm64.zip
            standalone_archive: zip
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            engine_asset: tandem-engine-windows-x64.zip
            tui_asset: tandem-tui-windows-x64.zip
            standalone_archive: zip

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            pkg-config \
            build-essential

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install dependencies
        run: pnpm install

      - name: Build bundled engine sidecar (Unix)
        if: ${{ matrix.platform != 'windows-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          cargo build --release -p tandem-ai --target ${{ matrix.target }}
          cargo build --release -p tandem-tui --target ${{ matrix.target }}
          mkdir -p src-tauri/resources/binaries
          cp "target/${{ matrix.target }}/release/tandem-engine" "src-tauri/resources/binaries/tandem-engine"
          chmod +x "src-tauri/resources/binaries/tandem-engine"

      - name: Build bundled engine sidecar (Windows)
        if: ${{ matrix.platform == 'windows-latest' }}
        shell: pwsh
        run: |
          cargo build --release -p tandem-ai --target ${{ matrix.target }}
          cargo build --release -p tandem-tui --target ${{ matrix.target }}
          New-Item -ItemType Directory -Path "src-tauri/resources/binaries" -Force | Out-Null
          Copy-Item "target/${{ matrix.target }}/release/tandem-engine.exe" "src-tauri/resources/binaries/tandem-engine.exe" -Force

      # NOTE: We only attempt macOS signing/notarization when explicitly enabled via
      # `MACOS_SIGNING_ENABLED=true` (repo variable). This prevents release builds from
      # failing when Apple cert secrets are missing or misconfigured.
      - name: Prepare App Store Connect API key (optional, for notarization)
        if: ${{ matrix.platform == 'macos-latest' }}
        id: asc_api_key
        shell: bash
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_P8: ${{ secrets.APPLE_API_KEY_P8 }}
        run: |
          set -euo pipefail
          # Default output to empty so downstream steps can safely reference it.
          echo "key_path=" >> "$GITHUB_OUTPUT"

          if [ "${MACOS_SIGNING_ENABLED:-}" != "true" ]; then
            echo "MACOS_SIGNING_ENABLED is not true; skipping."
            exit 0
          fi

          if [ -z "${APPLE_API_KEY:-}" ] || [ -z "${APPLE_API_KEY_P8:-}" ]; then
            echo "App Store Connect API key not configured; skipping."
            exit 0
          fi

          mkdir -p "$RUNNER_TEMP/apple-notary"
          KEY_PATH="$RUNNER_TEMP/apple-notary/AuthKey_${APPLE_API_KEY}.p8"
          # Use printf to preserve exact content (p8 secrets are multiline).
          printf '%s' "$APPLE_API_KEY_P8" > "$KEY_PATH"
          chmod 600 "$KEY_PATH"
          echo "key_path=$KEY_PATH" >> "$GITHUB_OUTPUT"

      - name: Build and upload (macOS, unsigned)
        if: ${{ matrix.platform == 'macos-latest' && env.MACOS_SIGNING_ENABLED != 'true' }}
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          retryAttempts: 3
          args: --target ${{ matrix.target }}
          updaterJsonPreferNsis: true

      - name: Build and upload (macOS, signed/notarized)
        if: ${{ matrix.platform == 'macos-latest' && env.MACOS_SIGNING_ENABLED == 'true' }}
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # macOS codesigning (Developer ID)
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Notarization (preferred: App Store Connect API key)
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_PATH: ${{ steps.asc_api_key.outputs.key_path }}
          # Notarization (fallback: Apple ID + app-specific password)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          retryAttempts: 3
          args: --target ${{ matrix.target }}
          updaterJsonPreferNsis: true

      - name: Verify macOS DMG (Gatekeeper)
        if: ${{ matrix.platform == 'macos-latest' }}
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
        run: |
          set -euo pipefail

          if [ "${MACOS_SIGNING_ENABLED:-}" != "true" ]; then
            echo "MACOS_SIGNING_ENABLED is not true; skipping Gatekeeper validation."
            exit 0
          fi

          if [ -z "${APPLE_CERTIFICATE:-}" ]; then
            echo "Apple signing not configured; skipping Gatekeeper validation."
            exit 0
          fi

          echo "Locating DMG..."
          DMG=""
          for p in \
            "src-tauri/target/${{ matrix.target }}/release/bundle/dmg" \
            "src-tauri/target/release/bundle/dmg" \
          ; do
            if [ -d "$p" ]; then
              DMG="$(ls -1 "$p"/*.dmg 2>/dev/null | head -n 1 || true)"
              if [ -n "$DMG" ]; then break; fi
            fi
          done
          if [ -z "$DMG" ]; then
            DMG="$(find src-tauri/target -path "*/bundle/dmg/*.dmg" -maxdepth 6 -print 2>/dev/null | head -n 1 || true)"
          fi
          if [ -z "$DMG" ]; then
            echo "No DMG found under src-tauri/target/**/bundle/dmg."
            exit 1
          fi
          echo "DMG: $DMG"

          MOUNT="$RUNNER_TEMP/tandem-dmg-mount"
          mkdir -p "$MOUNT"
          hdiutil attach -nobrowse -readonly -mountpoint "$MOUNT" "$DMG"
          APP="$(find "$MOUNT" -maxdepth 2 -name "*.app" -print | head -n 1 || true)"
          if [ -z "$APP" ]; then
            echo "No .app found in mounted DMG."
            hdiutil detach "$MOUNT" || true
            exit 1
          fi
          echo "App: $APP"

          echo "codesign verify..."
          codesign --verify --deep --strict --verbose=2 "$APP"

          echo "codesign details..."
          codesign -dv --verbose=4 "$APP" 2>&1 | head -n 120

          echo "spctl Gatekeeper assessment..."
          spctl -a -vvv --type execute "$APP"

          echo "xattr (quarantine) ..."
          xattr -lr "$APP" 2>/dev/null | head -n 120 || true

          echo "stapler validate (will fail if not notarized)..."
          stapler validate "$APP"

          hdiutil detach "$MOUNT"

      - name: Build and upload (non-macOS)
        if: ${{ matrix.platform != 'macos-latest' }}
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          retryAttempts: 3
          args: --target ${{ matrix.target }}
          updaterJsonPreferNsis: true

      - name: Package standalone engine/tui assets (Windows)
        if: ${{ matrix.platform == 'windows-latest' }}
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Path dist -Force | Out-Null
          Copy-Item "target/${{ matrix.target }}/release/tandem-engine.exe" "dist/tandem-engine.exe" -Force
          Copy-Item "target/${{ matrix.target }}/release/tandem-tui.exe" "dist/tandem-tui.exe" -Force
          Compress-Archive -Path "dist/tandem-engine.exe" -DestinationPath "dist/${{ matrix.engine_asset }}" -Force
          Compress-Archive -Path "dist/tandem-tui.exe" -DestinationPath "dist/${{ matrix.tui_asset }}" -Force

      - name: Package standalone engine/tui assets (Unix)
        if: ${{ matrix.platform != 'windows-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist
          cp "target/${{ matrix.target }}/release/tandem-engine" dist/tandem-engine
          cp "target/${{ matrix.target }}/release/tandem-tui" dist/tandem-tui
          chmod +x dist/tandem-engine dist/tandem-tui

          if [ "${{ matrix.standalone_archive }}" = "zip" ]; then
            zip -j "dist/${{ matrix.engine_asset }}" dist/tandem-engine
            zip -j "dist/${{ matrix.tui_asset }}" dist/tandem-tui
          else
            tar -czf "dist/${{ matrix.engine_asset }}" -C dist tandem-engine
            tar -czf "dist/${{ matrix.tui_asset }}" -C dist tandem-tui
          fi

      - name: Upload standalone engine/tui assets to release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          ENGINE_ASSET: ${{ matrix.engine_asset }}
          TUI_ASSET: ${{ matrix.tui_asset }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = Number(process.env.RELEASE_ID);
            const assets = [
              process.env.ENGINE_ASSET,
              process.env.TUI_ASSET,
            ].filter(Boolean);

            const existing = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              per_page: 100,
            });

            for (const assetName of assets) {
              const assetPath = path.join(process.cwd(), 'dist', assetName);
              const data = fs.readFileSync(assetPath);
              const contentType = assetName.endsWith('.zip')
                ? 'application/zip'
                : 'application/gzip';

              const duplicate = existing.data.find((asset) => asset.name === assetName);
              if (duplicate) {
                await github.rest.repos.deleteReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  asset_id: duplicate.id,
                });
              }

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: assetName,
                data,
                headers: {
                  'content-type': contentType,
                  'content-length': data.length,
                },
              });
            }

  publish-release:
    name: Publish Release
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    steps:
      - name: Publish release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: process.env.RELEASE_ID,
              draft: false
            });

  notify-discord:
    name: Notify Discord
    needs: [create-release, publish-release]
    runs-on: ubuntu-latest
    steps:
      - name: Check Discord webhook
        id: discord_webhook
        shell: bash
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        run: |
          if [ -n "${DISCORD_WEBHOOK_URL:-}" ]; then
            echo "configured=true" >> "$GITHUB_OUTPUT"
          else
            echo "configured=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Post release to Discord
        if: ${{ steps.discord_webhook.outputs.configured == 'true' }}
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          DISCORD_WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        with:
          script: |
            const releaseId = process.env.RELEASE_ID;
            const webhook = process.env.DISCORD_WEBHOOK_URL;
            if (!releaseId || !webhook) {
              core.warning('Missing RELEASE_ID or DISCORD_WEBHOOK_URL; skipping Discord notification.');
              return;
            }

            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: Number(releaseId),
            });

            // Discord limits: content <= 2000 chars; embed description <= 4096 chars.
            const truncate = (s, n) => (s && s.length > n ? `${s.slice(0, n - 3)}...` : (s || ''));
            const description = truncate(release.body, 4000);

            const payload = {
              content: '||@everyone||',
              embeds: [
                {
                  title: release.name || release.tag_name,
                  url: release.html_url,
                  description,
                  color: 2105893,
                  footer: { text: 'Changelog' },
                },
              ],
            };

            const resp = await fetch(webhook, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify(payload),
            });

            if (!resp.ok) {
              const text = await resp.text().catch(() => '');
              core.setFailed(`Discord webhook failed: ${resp.status} ${resp.statusText} ${text}`.trim());
            }
