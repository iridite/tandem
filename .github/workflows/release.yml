name: Release

on:
  push:
    tags:
      - "v*"
      - "*.*.*"

permissions:
  contents: write

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  # Safety toggle: macOS signing/notarization is disabled by default to avoid breaking builds.
  # To enable, set a GitHub Actions repository variable: MACOS_SIGNING_ENABLED=true
  MACOS_SIGNING_ENABLED: ${{ vars.MACOS_SIGNING_ENABLED }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Generate release notes
        run: node scripts/extract-release-notes.js "${{ github.ref_name }}" > release_notes.md

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: context.ref.replace('refs/tags/', ''),
              name: `Tandem ${context.ref.replace('refs/tags/', '')}`,
              body: releaseNotes,
              draft: true,
              prerelease: false,
              generate_release_notes: false
            });
            return data.id;

  build-release:
    name: Build (${{ matrix.platform }})
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
          - platform: macos-latest
            target: x86_64-apple-darwin
          - platform: macos-latest
            target: aarch64-apple-darwin
          - platform: windows-latest
            target: x86_64-pc-windows-msvc

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            pkg-config \
            build-essential

      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install dependencies
        run: pnpm install

      # NOTE: We only attempt macOS signing/notarization when explicitly enabled via
      # `MACOS_SIGNING_ENABLED=true` (repo variable). This prevents release builds from
      # failing when Apple cert secrets are missing or misconfigured.
      - name: Prepare App Store Connect API key (optional, for notarization)
        if: ${{ matrix.platform == 'macos-latest' }}
        id: asc_api_key
        shell: bash
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_P8: ${{ secrets.APPLE_API_KEY_P8 }}
        run: |
          set -euo pipefail
          # Default output to empty so downstream steps can safely reference it.
          echo "key_path=" >> "$GITHUB_OUTPUT"

          if [ "${MACOS_SIGNING_ENABLED:-}" != "true" ]; then
            echo "MACOS_SIGNING_ENABLED is not true; skipping."
            exit 0
          fi

          if [ -z "${APPLE_API_KEY:-}" ] || [ -z "${APPLE_API_KEY_P8:-}" ]; then
            echo "App Store Connect API key not configured; skipping."
            exit 0
          fi

          mkdir -p "$RUNNER_TEMP/apple-notary"
          KEY_PATH="$RUNNER_TEMP/apple-notary/AuthKey_${APPLE_API_KEY}.p8"
          # Use printf to preserve exact content (p8 secrets are multiline).
          printf '%s' "$APPLE_API_KEY_P8" > "$KEY_PATH"
          chmod 600 "$KEY_PATH"
          echo "key_path=$KEY_PATH" >> "$GITHUB_OUTPUT"

      - name: Build and upload (macOS, unsigned)
        if: ${{ matrix.platform == 'macos-latest' && env.MACOS_SIGNING_ENABLED != 'true' }}
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          retryAttempts: 3
          args: --target ${{ matrix.target }}
          updaterJsonPreferNsis: true

      - name: Build and upload (macOS, signed/notarized)
        if: ${{ matrix.platform == 'macos-latest' && env.MACOS_SIGNING_ENABLED == 'true' }}
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # macOS codesigning (Developer ID)
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Notarization (preferred: App Store Connect API key)
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_PATH: ${{ steps.asc_api_key.outputs.key_path }}
          # Notarization (fallback: Apple ID + app-specific password)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          retryAttempts: 3
          args: --target ${{ matrix.target }}
          updaterJsonPreferNsis: true

      - name: Verify macOS DMG (Gatekeeper)
        if: ${{ matrix.platform == 'macos-latest' }}
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
        run: |
          set -euo pipefail

          if [ "${MACOS_SIGNING_ENABLED:-}" != "true" ]; then
            echo "MACOS_SIGNING_ENABLED is not true; skipping Gatekeeper validation."
            exit 0
          fi

          if [ -z "${APPLE_CERTIFICATE:-}" ]; then
            echo "Apple signing not configured; skipping Gatekeeper validation."
            exit 0
          fi

          echo "Locating DMG..."
          DMG=""
          for p in \
            "src-tauri/target/${{ matrix.target }}/release/bundle/dmg" \
            "src-tauri/target/release/bundle/dmg" \
          ; do
            if [ -d "$p" ]; then
              DMG="$(ls -1 "$p"/*.dmg 2>/dev/null | head -n 1 || true)"
              if [ -n "$DMG" ]; then break; fi
            fi
          done
          if [ -z "$DMG" ]; then
            DMG="$(find src-tauri/target -path "*/bundle/dmg/*.dmg" -maxdepth 6 -print 2>/dev/null | head -n 1 || true)"
          fi
          if [ -z "$DMG" ]; then
            echo "No DMG found under src-tauri/target/**/bundle/dmg."
            exit 1
          fi
          echo "DMG: $DMG"

          MOUNT="$RUNNER_TEMP/tandem-dmg-mount"
          mkdir -p "$MOUNT"
          hdiutil attach -nobrowse -readonly -mountpoint "$MOUNT" "$DMG"
          APP="$(find "$MOUNT" -maxdepth 2 -name "*.app" -print | head -n 1 || true)"
          if [ -z "$APP" ]; then
            echo "No .app found in mounted DMG."
            hdiutil detach "$MOUNT" || true
            exit 1
          fi
          echo "App: $APP"

          echo "codesign verify..."
          codesign --verify --deep --strict --verbose=2 "$APP"

          echo "codesign details..."
          codesign -dv --verbose=4 "$APP" 2>&1 | head -n 120

          echo "spctl Gatekeeper assessment..."
          spctl -a -vvv --type execute "$APP"

          echo "xattr (quarantine) ..."
          xattr -lr "$APP" 2>/dev/null | head -n 120 || true

          echo "stapler validate (will fail if not notarized)..."
          stapler validate "$APP"

          hdiutil detach "$MOUNT"

      - name: Build and upload (non-macOS)
        if: ${{ matrix.platform != 'macos-latest' }}
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          retryAttempts: 3
          args: --target ${{ matrix.target }}
          updaterJsonPreferNsis: true

  publish-release:
    name: Publish Release
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    steps:
      - name: Publish release
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: process.env.RELEASE_ID,
              draft: false
            });

  notify-discord:
    name: Notify Discord
    needs: [create-release, publish-release]
    runs-on: ubuntu-latest
    steps:
      - name: Check Discord webhook
        id: discord_webhook
        shell: bash
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        run: |
          if [ -n "${DISCORD_WEBHOOK_URL:-}" ]; then
            echo "configured=true" >> "$GITHUB_OUTPUT"
          else
            echo "configured=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Post release to Discord
        if: ${{ steps.discord_webhook.outputs.configured == 'true' }}
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          DISCORD_WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
        with:
          script: |
            const releaseId = process.env.RELEASE_ID;
            const webhook = process.env.DISCORD_WEBHOOK_URL;
            if (!releaseId || !webhook) {
              core.warning('Missing RELEASE_ID or DISCORD_WEBHOOK_URL; skipping Discord notification.');
              return;
            }

            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: Number(releaseId),
            });

            // Discord limits: content <= 2000 chars; embed description <= 4096 chars.
            const truncate = (s, n) => (s && s.length > n ? `${s.slice(0, n - 3)}...` : (s || ''));
            const description = truncate(release.body, 4000);

            const payload = {
              content: '||@everyone||',
              embeds: [
                {
                  title: release.name || release.tag_name,
                  url: release.html_url,
                  description,
                  color: 2105893,
                  footer: { text: 'Changelog' },
                },
              ],
            };

            const resp = await fetch(webhook, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify(payload),
            });

            if (!resp.ok) {
              const text = await resp.text().catch(() => '');
              core.setFailed(`Discord webhook failed: ${resp.status} ${resp.statusText} ${text}`.trim());
            }
