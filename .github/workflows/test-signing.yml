name: Test Signing Keys

on:
  workflow_dispatch:

jobs:
  test-signing:
    name: Verify Signing Keys
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Tauri CLI
        run: npm install -g @tauri-apps/cli

      - name: Install minisign (for verification)
        run: |
          sudo apt-get update
          sudo apt-get install -y minisign

      - name: Extract public key from tauri.conf.json
        id: pubkey
        run: |
          PUBKEY=$(jq -r '.plugins.updater.pubkey' src-tauri/tauri.conf.json)
          echo "pubkey=$PUBKEY" >> $GITHUB_OUTPUT
          echo "Found public key: ${PUBKEY:0:50}..."

      - name: Test signing and verification
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          PUBLIC_KEY: ${{ steps.pubkey.outputs.pubkey }}
        run: |
          echo "Step 1: Basic secret diagnostics (no secret output)..."
          python - <<'PY'
          import os, re
          key = os.environ.get("TAURI_SIGNING_PRIVATE_KEY", "")
          print(f"Key length: {len(key)}")
          print(f"Starts with 'dW50'?: {key.startswith('dW50')}")
          print(f"Looks like Windows path?: {(':\\\\' in key) or (key.startswith('C:\\\\')) or ('.tauri' in key)}")
          invalid = re.sub(r"[A-Za-z0-9+/=\\r\\n]", "", key)
          print(f"Non-base64 chars count (excluding newlines): {len(invalid)}")
          if invalid:
            # Print only the first invalid char codepoint, not the char itself.
            print(f"First invalid char codepoint: {ord(invalid[0])}")
          PY

          echo "Step 2: Creating test file..."
          echo "test content" > test.txt

          echo "Step 3: Signing test file with private key..."
          # Tauri CLI expects the key string via -k/TAURI_PRIVATE_KEY (not a path).
          tauri signer sign -k "$TAURI_SIGNING_PRIVATE_KEY" -p "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" test.txt

          echo "Step 4: Verifying signature with public key (minisign)..."
          # `PUBLIC_KEY` is base64; decode to minisign public key format, then verify.
          printf '%s' "$PUBLIC_KEY" | base64 -d > /tmp/public.key
          # Tauri produces a `.sig` file; minisign defaults to `.minisig` unless specified.
          # Tauri's `.sig` is base64-encoded minisign signature content. Decode it first.
          base64 -d test.txt.sig > test.txt.minisig
          minisign -Vm test.txt -x test.txt.minisig -p /tmp/public.key

          echo "âœ… SUCCESS! Private key, password, and public key all match!"

          # Cleanup
          rm -f /tmp/public.key test.txt test.txt.sig test.txt.minisig
