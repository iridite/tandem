<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tandem Engine Browser Playground</title>
    <style>
      :root {
        --bg: #0b0f18;
        --panel: #111726;
        --panel-border: #28324a;
        --text: #e8eefc;
        --muted: #98a7c8;
        --brand: #31d0aa;
        --brand-2: #41a8ff;
        --warn: #ffcf5a;
        --danger: #ff6a87;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Avenir Next", "Futura", sans-serif;
        color: var(--text);
        background:
          radial-gradient(1200px 600px at 10% -10%, #1e2c50 0%, transparent 60%),
          radial-gradient(900px 500px at 100% 0%, #1a3e4f 0%, transparent 65%),
          var(--bg);
      }

      .wrap {
        max-width: 1100px;
        margin: 28px auto;
        padding: 0 16px;
      }

      h1 {
        margin: 0 0 8px;
        font-size: 30px;
      }

      .sub {
        color: var(--muted);
        margin-bottom: 20px;
      }

      .panel {
        border: 1px solid var(--panel-border);
        border-radius: 16px;
        background: linear-gradient(180deg, #10182a 0%, #0f1626 100%);
        box-shadow: 0 12px 34px rgba(0, 0, 0, 0.35);
      }

      .top {
        padding: 14px;
        display: grid;
        grid-template-columns: 1fr 1fr auto auto;
        gap: 10px;
      }

      .main {
        margin-top: 14px;
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 14px;
      }

      @media (max-width: 900px) {
        .top {
          grid-template-columns: 1fr;
        }
        .main {
          grid-template-columns: 1fr;
        }
      }

      .field {
        display: grid;
        gap: 6px;
      }

      .field label {
        color: var(--muted);
        font-size: 12px;
        letter-spacing: 0.02em;
      }

      input,
      textarea,
      button {
        border-radius: 10px;
        border: 1px solid #334162;
        background: #0d1322;
        color: var(--text);
        padding: 10px 12px;
        font-size: 14px;
      }

      input:focus,
      textarea:focus {
        outline: none;
        border-color: var(--brand-2);
        box-shadow: 0 0 0 2px rgba(65, 168, 255, 0.25);
      }

      button {
        cursor: pointer;
        font-weight: 600;
      }

      .btn-connect {
        background: linear-gradient(90deg, var(--brand-2), var(--brand));
        color: #04121c;
        border: none;
      }

      .btn-send {
        background: linear-gradient(90deg, #43ccff, #31d0aa);
        color: #06201a;
        border: none;
      }

      .btn-secondary {
        background: #0f1a2c;
        color: var(--text);
        border: 1px solid #2b3b5d;
      }

      .status {
        align-self: end;
        font-size: 13px;
        color: var(--muted);
      }

      .chat {
        height: 520px;
        display: grid;
        grid-template-rows: 1fr auto;
        overflow: hidden;
      }

      .messages {
        padding: 14px;
        overflow: auto;
        display: grid;
        gap: 10px;
        align-content: start;
      }

      .bubble {
        max-width: 90%;
        padding: 10px 12px;
        border-radius: 12px;
        line-height: 1.45;
        white-space: pre-wrap;
      }

      .bubble.md {
        white-space: normal;
      }

      .bubble.md p {
        margin: 0 0 0.7em;
      }

      .bubble.md p:last-child {
        margin-bottom: 0;
      }

      .bubble.md pre {
        margin: 0.6em 0;
        overflow: auto;
        border: 1px solid #2b3550;
        border-radius: 8px;
        background: #0b1322;
        padding: 10px;
      }

      .bubble.md code {
        font-family: "JetBrains Mono", "Cascadia Mono", "Fira Mono", monospace;
        font-size: 0.92em;
      }

      .bubble.md :not(pre) > code {
        border: 1px solid #2b3550;
        border-radius: 6px;
        background: #0b1322;
        padding: 1px 5px;
      }

      .bubble.md ul,
      .bubble.md ol {
        margin: 0.4em 0 0.7em 1.25em;
      }

      .bubble.md h1,
      .bubble.md h2,
      .bubble.md h3,
      .bubble.md h4 {
        margin: 0.2em 0 0.45em;
        line-height: 1.2;
      }

      .bubble.md a {
        color: #7cc7ff;
      }

      .user {
        justify-self: end;
        background: #1a2f5f;
        border: 1px solid #2f4d93;
      }

      .assistant {
        justify-self: start;
        background: #142233;
        border: 1px solid #29425f;
      }

      .assistant.live {
        border-style: dashed;
      }

      .assistant.thinking {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        min-height: 40px;
      }

      .assistant.thinking .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: #7cc7ff;
        opacity: 0.35;
        animation: think-bounce 1.1s infinite ease-in-out;
      }

      .assistant.thinking .dot:nth-child(2) {
        animation-delay: 0.15s;
      }

      .assistant.thinking .dot:nth-child(3) {
        animation-delay: 0.3s;
      }

      @keyframes think-bounce {
        0%,
        80%,
        100% {
          transform: translateY(0);
          opacity: 0.35;
        }
        40% {
          transform: translateY(-4px);
          opacity: 1;
        }
      }

      .system {
        justify-self: center;
        max-width: 100%;
        color: var(--muted);
        font-size: 12px;
      }

      .approval {
        justify-self: center;
        max-width: 100%;
        border: 1px solid #2b3b5d;
        background: #0e1627;
        border-radius: 12px;
        padding: 10px 12px;
        display: grid;
        gap: 8px;
      }

      .approval-title {
        font-size: 13px;
        color: var(--muted);
      }

      .approval-meta {
        font-family: "JetBrains Mono", "Cascadia Mono", "Fira Mono", monospace;
        font-size: 12px;
        white-space: pre-wrap;
        background: #0b1322;
        border: 1px solid #2b3550;
        border-radius: 8px;
        padding: 8px;
      }

      .approval-actions {
        display: flex;
        gap: 8px;
      }

      .btn-approve {
        background: linear-gradient(90deg, #31d0aa, #5ad88f);
        color: #04121c;
        border: none;
      }

      .btn-deny {
        background: #2a1522;
        color: #ffb4c4;
        border: 1px solid #5a2a3d;
      }

      .composer {
        border-top: 1px solid var(--panel-border);
        padding: 12px;
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 10px;
      }

      .composer textarea {
        resize: vertical;
        min-height: 44px;
        max-height: 140px;
      }

      .events {
        height: 520px;
        display: grid;
        grid-template-rows: auto 1fr;
        overflow: hidden;
      }

      .ops {
        margin-top: 14px;
        padding: 12px;
        display: grid;
        gap: 10px;
      }

      .ops-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 8px;
      }

      @media (max-width: 900px) {
        .ops-grid {
          grid-template-columns: 1fr 1fr;
        }
      }

      .events-head {
        padding: 12px;
        border-bottom: 1px solid var(--panel-border);
        color: var(--muted);
        font-size: 12px;
      }

      .events-log {
        margin: 0;
        padding: 12px;
        list-style: none;
        overflow: auto;
        display: grid;
        gap: 8px;
        font-family: "JetBrains Mono", "Cascadia Mono", "Fira Mono", monospace;
        font-size: 12px;
      }

      .events-log li {
        border: 1px solid #2b3550;
        background: #0f1525;
        border-radius: 10px;
        padding: 8px;
      }

      .ev-type {
        color: var(--warn);
      }

      .ev-run {
        color: var(--brand);
      }

      .error {
        color: var(--danger);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Tandem Engine Browser Playground</h1>
      <div class="sub">
        Live chat + SSE event stream with token auth. Great for testing external integrations.
      </div>

      <div class="panel top">
        <div class="field">
          <label>Engine URL</label>
          <input id="apiUrl" value="http://127.0.0.1:39731" />
        </div>
        <div class="field">
          <label>API Token (X-Tandem-Token)</label>
          <input id="token" placeholder="tk_..." />
        </div>
        <button id="connectBtn" class="btn-connect">Connect</button>
        <button id="disconnectBtn" class="btn-secondary" disabled>Disconnect</button>
        <button id="clearBtn" class="btn-secondary">Clear</button>
        <div id="status" class="status">Not connected</div>
      </div>

      <div class="main">
        <div class="panel chat">
          <div id="messages" class="messages"></div>
          <div class="composer">
            <textarea id="prompt" placeholder="Ask the engine something..."></textarea>
            <button id="sendBtn" class="btn-send" disabled>Send</button>
            <button id="stopBtn" class="btn-secondary" disabled>Stop</button>
          </div>
        </div>

        <div class="panel events">
          <div class="events-head">Live SSE events</div>
          <ul id="events" class="events-log"></ul>
        </div>
      </div>

      <div class="panel ops">
        <div class="field">
          <label>Mission Event Payload (JSON for <code>/mission/{id}/event</code>)</label>
          <textarea id="missionEventJson" rows="4" placeholder='{"type":"mission_started","mission_id":"..."}'></textarea>
        </div>
        <div class="ops-grid">
          <button id="missionCreateBtn" class="btn-secondary" disabled>Create Demo Mission</button>
          <button id="missionsListBtn" class="btn-secondary" disabled>List Missions</button>
          <button id="missionApplyBtn" class="btn-secondary" disabled>Apply Mission Event</button>
          <button id="routinesListBtn" class="btn-secondary" disabled>List Routines</button>
        </div>
      </div>
    </div>

    <script>
      const ui = {
        apiUrl: document.getElementById("apiUrl"),
        token: document.getElementById("token"),
        connectBtn: document.getElementById("connectBtn"),
        disconnectBtn: document.getElementById("disconnectBtn"),
        clearBtn: document.getElementById("clearBtn"),
        status: document.getElementById("status"),
        prompt: document.getElementById("prompt"),
        sendBtn: document.getElementById("sendBtn"),
        stopBtn: document.getElementById("stopBtn"),
        messages: document.getElementById("messages"),
        events: document.getElementById("events"),
        missionEventJson: document.getElementById("missionEventJson"),
        missionCreateBtn: document.getElementById("missionCreateBtn"),
        missionsListBtn: document.getElementById("missionsListBtn"),
        missionApplyBtn: document.getElementById("missionApplyBtn"),
        routinesListBtn: document.getElementById("routinesListBtn")
      };

      const state = {
        api: "",
        token: "",
        sessionId: "",
        busy: false,
        connected: false,
        streamAbort: null
      };

      const storageKey = "tandem-example";

      function loadSettings() {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (parsed?.apiUrl) ui.apiUrl.value = parsed.apiUrl;
          if (parsed?.token) ui.token.value = parsed.token;
        } catch {}
      }

      function saveSettings() {
        const payload = {
          apiUrl: ui.apiUrl.value.trim(),
          token: ui.token.value.trim()
        };
        localStorage.setItem(storageKey, JSON.stringify(payload));
      }

      function authHeaders(json = true) {
        const headers = {};
        if (json) headers["content-type"] = "application/json";
        if (state.token) headers["X-Tandem-Token"] = state.token;
        return headers;
      }

      function setStatus(text, isError = false) {
        ui.status.textContent = text;
        ui.status.classList.toggle("error", isError);
      }

      function setConnected(connected) {
        state.connected = connected;
        ui.connectBtn.disabled = connected;
        ui.disconnectBtn.disabled = !connected;
        ui.sendBtn.disabled = !connected || state.busy;
        ui.missionCreateBtn.disabled = !connected;
        ui.missionsListBtn.disabled = !connected;
        ui.missionApplyBtn.disabled = !connected;
        ui.routinesListBtn.disabled = !connected;
      }

      function stopStream() {
        if (state.streamAbort) {
          state.streamAbort.abort();
          state.streamAbort = null;
        }
        ui.stopBtn.disabled = true;
      }

      function clearAll() {
        ui.messages.innerHTML = "";
        ui.events.innerHTML = "";
      }

      function pushMessage(role, text, live = false) {
        const div = document.createElement("div");
        div.className = `bubble ${role} ${live ? "live" : ""}`;
        div.textContent = text;
        ui.messages.appendChild(div);
        ui.messages.scrollTop = ui.messages.scrollHeight;
        return div;
      }

      function escapeHtml(input) {
        return String(input)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function renderInlineMarkdown(text) {
        let out = text;
        out = out.replace(/`([^`]+)`/g, "<code>$1</code>");
        out = out.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        out = out.replace(/\*([^*\n]+)\*/g, "<em>$1</em>");
        out = out.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
        return out;
      }

      function renderMarkdown(text) {
        const escaped = escapeHtml(text || "");
        const codeBlocks = [];
        let src = escaped.replace(/```([\s\S]*?)```/g, (_, block) => {
          const i = codeBlocks.push(`<pre><code>${block.trim()}</code></pre>`) - 1;
          return `@@CODEBLOCK_${i}@@`;
        });

        const lines = src.split(/\r?\n/);
        const html = [];
        let inUl = false;
        let inOl = false;

        const closeLists = () => {
          if (inUl) {
            html.push("</ul>");
            inUl = false;
          }
          if (inOl) {
            html.push("</ol>");
            inOl = false;
          }
        };

        for (const rawLine of lines) {
          const line = rawLine.trimEnd();
          const trimmed = line.trim();

          if (!trimmed) {
            closeLists();
            continue;
          }

          const codeMatch = trimmed.match(/^@@CODEBLOCK_(\d+)@@$/);
          if (codeMatch) {
            closeLists();
            html.push(codeBlocks[Number(codeMatch[1])] || "");
            continue;
          }

          const heading = trimmed.match(/^(#{1,4})\s+(.+)$/);
          if (heading) {
            closeLists();
            const level = heading[1].length;
            html.push(`<h${level}>${renderInlineMarkdown(heading[2])}</h${level}>`);
            continue;
          }

          const ulItem = trimmed.match(/^[-*]\s+(.+)$/);
          if (ulItem) {
            if (inOl) {
              html.push("</ol>");
              inOl = false;
            }
            if (!inUl) {
              html.push("<ul>");
              inUl = true;
            }
            html.push(`<li>${renderInlineMarkdown(ulItem[1])}</li>`);
            continue;
          }

          const olItem = trimmed.match(/^\d+\.\s+(.+)$/);
          if (olItem) {
            if (inUl) {
              html.push("</ul>");
              inUl = false;
            }
            if (!inOl) {
              html.push("<ol>");
              inOl = true;
            }
            html.push(`<li>${renderInlineMarkdown(olItem[1])}</li>`);
            continue;
          }

          closeLists();
          html.push(`<p>${renderInlineMarkdown(trimmed)}</p>`);
        }

        closeLists();
        return html.join("\n");
      }

      function setMarkdownMessage(element, text) {
        element.classList.remove("thinking");
        element.classList.add("md");
        element.innerHTML = renderMarkdown(text);
      }

      function pushSystem(text, isError = false) {
        const div = document.createElement("div");
        div.className = `system${isError ? " error" : ""}`;
        div.textContent = text;
        ui.messages.appendChild(div);
        ui.messages.scrollTop = ui.messages.scrollHeight;
      }

      function pushApprovalRequest(request) {
        const div = document.createElement("div");
        div.className = "approval";

        const title = document.createElement("div");
        title.className = "approval-title";
        title.textContent = "Approval required";

        const meta = document.createElement("div");
        meta.className = "approval-meta";
        const payload = {
          sessionID: request.sessionID || request.sessionId || "",
          requestID: request.requestID || request.requestId || "",
          tool: request.tool || "",
          query: request.query || undefined,
          args: request.args || {}
        };
        meta.textContent = JSON.stringify(payload, null, 2);

        const actions = document.createElement("div");
        actions.className = "approval-actions";

        const approveBtn = document.createElement("button");
        approveBtn.className = "btn-approve";
        approveBtn.textContent = "Approve";

        const denyBtn = document.createElement("button");
        denyBtn.className = "btn-deny";
        denyBtn.textContent = "Deny";

        const resolve = (label) => {
          approveBtn.disabled = true;
          denyBtn.disabled = true;
          title.textContent = label;
        };

        approveBtn.addEventListener("click", async () => {
          const sessionId = request.sessionID || request.sessionId || state.sessionId;
          const requestId = request.requestID || request.requestId;
          if (!sessionId || !requestId) return;
          try {
            await fetch(
              `${state.api}/sessions/${encodeURIComponent(sessionId)}/tools/${encodeURIComponent(requestId)}/approve`,
              { method: "POST", headers: authHeaders(false) }
            );
            resolve("Approved");
          } catch (err) {
            pushSystem(String(err.message || err), true);
          }
        });

        denyBtn.addEventListener("click", async () => {
          const sessionId = request.sessionID || request.sessionId || state.sessionId;
          const requestId = request.requestID || request.requestId;
          if (!sessionId || !requestId) return;
          try {
            await fetch(
              `${state.api}/sessions/${encodeURIComponent(sessionId)}/tools/${encodeURIComponent(requestId)}/deny`,
              { method: "POST", headers: authHeaders(false) }
            );
            resolve("Denied");
          } catch (err) {
            pushSystem(String(err.message || err), true);
          }
        });

        actions.appendChild(approveBtn);
        actions.appendChild(denyBtn);

        div.appendChild(title);
        div.appendChild(meta);
        div.appendChild(actions);
        ui.messages.appendChild(div);
        ui.messages.scrollTop = ui.messages.scrollHeight;
      }

      function makeThinkingBubble() {
        const bubble = pushMessage("assistant", "", true);
        bubble.classList.add("thinking");
        bubble.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
        return bubble;
      }

      function pushEvent(evt) {
        const li = document.createElement("li");
        const type = evt.type || "unknown";
        const runId = evt.properties?.runID || evt.properties?.runId || "-";
        li.innerHTML = `<span class="ev-type">${type}</span> <span class="ev-run">run=${runId}</span>\n${JSON.stringify(evt.properties || {}, null, 2)}`;
        ui.events.appendChild(li);
        ui.events.scrollTop = ui.events.scrollHeight;
      }

      async function apiGet(path) {
        const res = await fetch(`${state.api}${path}`, { headers: authHeaders(false) });
        if (!res.ok) {
          throw new Error(`${path} failed (${res.status}): ${await res.text()}`);
        }
        return res.json();
      }

      async function apiPost(path, body) {
        const res = await fetch(`${state.api}${path}`, {
          method: "POST",
          headers: authHeaders(true),
          body: JSON.stringify(body)
        });
        if (!res.ok) {
          throw new Error(`${path} failed (${res.status}): ${await res.text()}`);
        }
        return res.json();
      }

      function extractRunId(run) {
        return (
          run?.id ||
          run?.runID ||
          run?.run_id ||
          run?.run?.id ||
          run?.run?.runID ||
          run?.run?.run_id ||
          ""
        );
      }

      function extractAttachPath(run) {
        return run?.attachEventStream || run?.attach_event_stream || run?.attachStream || "";
      }

      function normalizeStreamUrl(attachPath, sessionId, runId) {
        if (attachPath) {
          if (attachPath.startsWith("http://") || attachPath.startsWith("https://")) return attachPath;
          return `${state.api}${attachPath}`;
        }
        if (runId) return `${state.api}/event?sessionID=${encodeURIComponent(sessionId)}&runID=${encodeURIComponent(runId)}`;
        return `${state.api}/event?sessionID=${encodeURIComponent(sessionId)}`;
      }

      function messageRole(msg) {
        const direct = (msg?.role || "").toLowerCase();
        if (direct) return direct;
        const nested = (msg?.info?.role || "").toLowerCase();
        if (nested) return nested;
        return "";
      }

      function textFromMessage(msg) {
        if (!msg) return "";
        const parts = Array.isArray(msg.parts) ? msg.parts : [];
        const chunks = [];
        for (const p of parts) {
          if (p?.type === "text" && typeof p.text === "string") chunks.push(p.text);
          else if (p?.type === "text" && typeof p.content === "string") chunks.push(p.content);
          else if (typeof p?.output === "string") chunks.push(p.output);
          else if (typeof p?.text === "string") chunks.push(p.text);
        }
        return chunks.join("\n").trim();
      }

      async function fetchLatestAssistantText(sessionId) {
        const res = await fetch(`${state.api}/session/${sessionId}/message`, {
          headers: authHeaders(false)
        });
        if (!res.ok) return "";
        const json = await res.json();
        const list = Array.isArray(json) ? json : Array.isArray(json?.messages) ? json.messages : [];
        for (let i = list.length - 1; i >= 0; i -= 1) {
          if (messageRole(list[i]) === "assistant") {
            const txt = textFromMessage(list[i]);
            if (txt) return txt;
          }
        }
        return "";
      }

      async function connect() {
        state.api = ui.apiUrl.value.trim().replace(/\/+$/, "");
        state.token = ui.token.value.trim();
        if (!state.api) {
          setStatus("Missing API URL", true);
          return;
        }

        setStatus("Connecting...");
        try {
          stopStream();
          const health = await fetch(`${state.api}/global/health`, {
            headers: authHeaders(false)
          }).then((r) => r.json());

          const session = await fetch(`${state.api}/session`, {
            method: "POST",
            headers: authHeaders(true),
            body: "{}"
          }).then(async (r) => {
            if (!r.ok) {
              const body = await r.text();
              throw new Error(`Session create failed (${r.status}): ${body}`);
            }
            return r.json();
          });

          state.sessionId = session.id;
          setConnected(true);
          saveSettings();
          setStatus(`Connected | session=${state.sessionId.slice(0, 8)}... | phase=${health.phase || "ready"}`);
          pushSystem(`session: ${state.sessionId}`);
        } catch (err) {
          setConnected(false);
          setStatus("Connection failed", true);
          pushSystem(String(err.message || err), true);
        }
      }

      function disconnect() {
        stopStream();
        state.sessionId = "";
        setConnected(false);
        setStatus("Disconnected");
        pushSystem("disconnected");
      }

      async function runPrompt(promptText) {
        const msg = { parts: [{ type: "text", text: promptText }] };

        await fetch(`${state.api}/session/${state.sessionId}/message`, {
          method: "POST",
          headers: authHeaders(true),
          body: JSON.stringify(msg)
        });

        const runRes = await fetch(`${state.api}/session/${state.sessionId}/prompt_async?return=run`, {
          method: "POST",
          headers: authHeaders(true),
          body: JSON.stringify(msg)
        });
        if (!runRes.ok) {
          const body = await runRes.text();
          throw new Error(`Run failed (${runRes.status}): ${body}`);
        }
        return runRes.json();
      }

      async function streamRun(streamUrl) {
        const controller = new AbortController();
        state.streamAbort = controller;
        ui.stopBtn.disabled = false;
        const res = await fetch(streamUrl, {
          headers: { ...authHeaders(false), Accept: "text/event-stream" },
          signal: controller.signal
        });
        if (!res.ok || !res.body) {
          const body = await res.text();
          throw new Error(`Stream failed (${res.status}): ${body}`);
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let assistantDraft = "";
        const liveBubble = makeThinkingBubble();
        let gotAssistantData = false;

        const takeEventBlocks = () => {
          const normalized = buffer.replace(/\r\n/g, "\n");
          const blocks = normalized.split("\n\n");
          buffer = blocks.pop() || "";
          return blocks;
        };

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          for (const block of takeEventBlocks()) {
            const dataLines = block
              .split("\n")
              .filter((line) => line.startsWith("data:"))
              .map((line) => line.slice(5).trim());
            if (!dataLines.length) continue;

            const raw = dataLines.join("\n");
            if (raw === "[DONE]") continue;

            let evt;
            try {
              evt = JSON.parse(raw);
            } catch {
              continue;
            }
            pushEvent(evt);

            const t = evt.type || "";
            const p = evt.properties || {};
            const maybeText =
              p.delta || p.text || p.content || p.output || p.message || "";

            if (t === "permission.asked") {
              pushApprovalRequest(p);
            }

            if (typeof maybeText === "string" && maybeText.trim()) {
              gotAssistantData = true;
              assistantDraft += maybeText;
              liveBubble.classList.remove("thinking");
              liveBubble.textContent = assistantDraft;
            }

            if (t === "session.error") {
              throw new Error(p.error || p.message || "Session error");
            }

            if (t === "session.run.finished") {
              if (p.status && p.status !== "completed") {
                throw new Error(`Run finished with status=${p.status}${p.error ? ` (${p.error})` : ""}`);
              }
              try {
                await reader.cancel();
              } catch {
                // no-op
              }
              break;
            }
          }
        }

        if (!gotAssistantData) {
          const fallback = await fetchLatestAssistantText(state.sessionId);
          if (fallback) {
            setMarkdownMessage(liveBubble, fallback);
          } else {
            liveBubble.classList.remove("thinking");
            liveBubble.textContent = "(No assistant text in stream; check provider configuration.)";
          }
        } else {
          setMarkdownMessage(liveBubble, assistantDraft);
        }
        liveBubble.classList.remove("live");
        stopStream();
      }

      async function send() {
        if (state.busy || !state.sessionId) return;
        const text = ui.prompt.value.trim();
        if (!text) return;

        ui.prompt.value = "";
        state.busy = true;
        ui.sendBtn.disabled = true;
        pushMessage("user", text);

        try {
          const run = await runPrompt(text);
          const runId = extractRunId(run);
          const attachPath = extractAttachPath(run);
          const streamUrl = normalizeStreamUrl(attachPath, state.sessionId, runId);
          pushSystem(`run started: ${runId || "unknown"}${attachPath ? " (attach stream)" : ""}`);
          await streamRun(streamUrl);
        } catch (err) {
          pushSystem(String(err.message || err), true);
        } finally {
          state.busy = false;
          ui.sendBtn.disabled = !state.connected;
          ui.prompt.focus();
        }
      }

      async function createDemoMission() {
        const payload = {
          title: "Browser demo mission",
          goal: "Exercise mission runtime APIs from docs/example.html",
          work_items: [
            { title: "Kick off mission", detail: "Generated from playground", assigned_agent: "general" }
          ]
        };
        const created = await apiPost("/mission", payload);
        const mission = created?.mission || {};
        const missionId = mission.mission_id || "";
        const workItemId = mission.work_items?.[0]?.work_item_id || "";
        if (missionId && workItemId) {
          ui.missionEventJson.value = JSON.stringify(
            {
              type: "run_finished",
              mission_id: missionId,
              work_item_id: workItemId,
              run_id: "run-browser-demo",
              status: "completed"
            },
            null,
            2
          );
        }
        pushSystem(`Mission created: ${missionId || "(unknown)"}`);
        pushEvent({ type: "mission.created", properties: mission });
      }

      async function listMissions() {
        const data = await apiGet("/mission");
        pushSystem(`Mission count: ${data?.count ?? 0}`);
        pushEvent({ type: "mission.list", properties: data });
      }

      async function applyMissionEvent() {
        const raw = ui.missionEventJson.value.trim();
        if (!raw) {
          throw new Error("Mission event JSON is empty");
        }
        const event = JSON.parse(raw);
        const missionId = event.mission_id;
        if (!missionId) {
          throw new Error("mission_id is required in event payload");
        }
        const data = await apiPost(`/mission/${encodeURIComponent(missionId)}/event`, { event });
        pushSystem(`Mission event applied: ${event.type || "unknown"} -> revision ${data?.mission?.revision ?? "?"}`);
        pushEvent({ type: "mission.updated", properties: data });
      }

      async function listRoutines() {
        const data = await apiGet("/routines");
        pushSystem(`Routine count: ${data?.count ?? 0}`);
        pushEvent({ type: "routine.list", properties: data });
      }

      ui.connectBtn.addEventListener("click", connect);
      ui.disconnectBtn.addEventListener("click", disconnect);
      ui.clearBtn.addEventListener("click", clearAll);
      ui.sendBtn.addEventListener("click", send);
      ui.stopBtn.addEventListener("click", stopStream);
      ui.prompt.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          send();
        }
      });
      ui.missionCreateBtn.addEventListener("click", async () => {
        try {
          await createDemoMission();
        } catch (err) {
          pushSystem(String(err.message || err), true);
        }
      });
      ui.missionsListBtn.addEventListener("click", async () => {
        try {
          await listMissions();
        } catch (err) {
          pushSystem(String(err.message || err), true);
        }
      });
      ui.missionApplyBtn.addEventListener("click", async () => {
        try {
          await applyMissionEvent();
        } catch (err) {
          pushSystem(String(err.message || err), true);
        }
      });
      ui.routinesListBtn.addEventListener("click", async () => {
        try {
          await listRoutines();
        } catch (err) {
          pushSystem(String(err.message || err), true);
        }
      });

      loadSettings();
    </script>
  </body>
</html>
